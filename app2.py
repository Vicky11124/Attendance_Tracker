import streamlit as st
import pandas as pd
from datetime import date
import numpy as np

st.set_page_config(page_title="Attendance Dashboard", layout="wide")
st.title("College Staff Attendance Dashboard")

# ----------- UTILITIES -----------------

def normalize_ecode(val):
    if pd.isnull(val):
        return ""
    return str(val).strip().upper()  # use upper for consistent matching

def normalize_status(val):
    if pd.isnull(val):
        return ""
    return str(val).strip().upper()

def normalize_date(val):
    if pd.isnull(val):
        return None
    try:
        d = pd.to_datetime(val, dayfirst=False, errors="coerce")
        return d.date() if not pd.isnull(d) else None
    except Exception:
        return None

# Handles both XLSX and CSV, tries to get "Date" as date
def read_attendance_file(uploaded):
    ext = uploaded.name.split('.')[-1].lower()
    if ext == 'xlsx':
        try:
            df = pd.read_excel(uploaded, dtype=str)
        except Exception:
            df = pd.read_excel(uploaded, dtype=str, header=None)
    else:
        df = pd.read_csv(uploaded, dtype=str)
    return df

def process_erp_table(df):
    # If proper columns, just use as is + cleanup
    if "E. Code" in df.columns and "Status" in df.columns:
        out = df.copy()
    else:
        # try to detect header row
        header_row = df.apply(lambda row: (row == "E. Code").any(), axis=1)
        if not header_row.any():
            st.error("Couldn't find 'E. Code' header!")
            return pd.DataFrame()
        idx = np.where(header_row)[0][0]
        columns = df.iloc[idx]
        out = df.iloc[idx+1:]
        out.columns = columns
    # Fix: Only use columns that are strings and exist in our set
    good_cols = ['E. Code', 'Name', 'Status', 'Date', 'Department', 'Shift']
    keep = [c for c in out.columns if isinstance(c, str) and c.strip() in good_cols]
    out = out[keep]
    return out

def ensure_date_column(df, file_label):
    if "Date" not in df.columns or df["Date"].isnull().all():
        ask = st.date_input(f"File '{file_label}' missing 'Date'. Pick date to use:", value=date.today(), key="date_"+file_label)
        df['Date'] = str(ask)
    # Always convert to date objects
    df["Date"] = df["Date"].apply(normalize_date)
    return df

def preprocess_common(df):
    # Strip whitespace, consistent case
    if 'E. Code' in df.columns:
        df['E. Code'] = df['E. Code'].fillna("").apply(normalize_ecode)
    if 'Status' in df.columns:
        df['Status'] = df['Status'].fillna("").apply(normalize_status)
    if 'Date' in df.columns:
        df['Date'] = df['Date'].apply(normalize_date)
    if 'Name' in df.columns:
        df['Name'] = df['Name'].fillna("").astype(str).str.strip()
    return df

def merge_od_with_erp(df_erp, df_od):
    # Make sure keys are normalized
    df_erp = preprocess_common(df_erp)
    df_od = preprocess_common(df_od)
    # Build override map: (E. Code, Date) => Status
    od_map = {(row['E. Code'], row['Date']): row['Status'] for _, row in df_od.iterrows() 
              if row.get('E. Code') and row.get('Date')}
    def merged_status(row):
        key = (row.get('E. Code'), row.get('Date'))
        return od_map.get(key, row.get('Status'))
    df_erp['Status'] = df_erp.apply(merged_status, axis=1)
    return df_erp

# -----------  APP UI/LOGIC ------------

st.markdown("**Step 1:** Upload your ERP (main attendance) file")
att_file = st.file_uploader("Upload ERP Attendance Excel/CSV", type=["xlsx","csv"], key="erpfile")

st.markdown("**Step 2:** Upload your OD/Special Leave file (generated by od5.py).")
od_file = st.file_uploader("Upload OD/Attendance File from od5.py", type=["xlsx","csv"], key="odfile")

att_df, od_df = None, None
if att_file:
    att_raw = read_attendance_file(att_file)
    att_df = process_erp_table(att_raw)    
    att_df = ensure_date_column(att_df, "ERP")
    att_df = preprocess_common(att_df)
    if att_df.empty:
        st.stop()
if od_file:
    od_df = read_attendance_file(od_file)
    if "E. Code" not in od_df.columns or "Status" not in od_df.columns:
        st.error("OD file must have at least E. Code and Status columns!")
        st.stop()
    od_df = ensure_date_column(od_df, "OD")
    od_df = preprocess_common(od_df)
    if od_df.empty:
        st.stop()

# -- Merge and summary
main_df = att_df
if att_df is not None and od_df is not None:
    main_df = merge_od_with_erp(att_df, od_df)

if main_df is not None and not main_df.empty:
    st.subheader("Attendance & Leave Summary")
    # Date range controls
    datemin = main_df['Date'].min()
    datemax = main_df['Date'].max()
    start = st.date_input("From", value=datemin, min_value=datemin, max_value=datemax, key="d1")
    end = st.date_input("To", value=datemax, min_value=datemin, max_value=datemax, key="d2")
    filtered = main_df[(main_df['Date'] >= start) & (main_df['Date'] <= end)]

    groupcols = ['E. Code','Name']

    statuses = filtered['Status'].dropna().unique().tolist()
    statuses = sorted([s for s in statuses if s != ''])  # ignore blanks

    # Produce count table with Present, Absent, OD, SSL, etc dynamically
    summ = (filtered.groupby(groupcols)['Status']
                   .value_counts()
                   .unstack(fill_value=0)
                   .reset_index())
    # Ensure at least these columns, fill if missing
    for col in ['PRESENT','ABSENT','OD']:
        if col not in summ.columns:
            summ[col] = 0
    # Custom statuses
    custom_statuses = [s for s in statuses if s not in ['PRESENT','ABSENT','OD']]
    cols = groupcols+['PRESENT','ABSENT','OD']+custom_statuses
    out = summ.loc[:, [c for c in cols if c in summ.columns]]
    st.dataframe(out)

    st.download_button("Download Summary CSV", data=out.to_csv(index=False), file_name=f"attendance_summary_{start}_to_{end}.csv", mime="text/csv")
else:
    st.info("Upload both ERP and OD/special leave files to see summary.")

st.info("App auto-normalizes all spaces and case in E. Code, Date, and Status for robust merging and group counting.")
